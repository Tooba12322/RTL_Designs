Basic RTL implementations :

1. ALU adder
2. Binary to Gray
3. Binary to OneHot
4. Gray to Binary
5. Comaprator
6. MUX in different styles
7. Flip Flops
8. Johnson counter
9. Ring counter
10. LUT
11. Latches
12. LFSR
13. 16x1 MUX structural modelling
14. PISO shift reg
15. PWM generator
16. Parity detector
17. Priority Encoder
18. SIPO shift register
19. Serial adder
20. Simple timer
21. Even Odd counter
22. Mod-10 counter
23. Up down counter
24. Edge detector
25. Variable swapping
26. Counter with load
27. Adder subtractor
28. 7-Seg to ASCII
29. Interface Design
30. UART Baud rate generator

Moderately difficult RTLs :

1. Round Robin Arbiter
2. Synchronous FIFO
3. ALU with flags
5. Gray counter
6. Dual Gray counter
7. GCD counter
8. Moore Machine
9. Multiplier
10. Priority arbiter
11. 32x32 Reg Bank
12. Sequence Detector without FSM
13. Sequence Detector Ex-1
14. Sequence Detector Ex-2
15. Sequence Detector Ex-3
16. Sequence Generator
17. Single port RAM
18. Memory interface

Complex RTL Designs :

1. Asynchronous FIFO
2. MIPS32 processor design
3. APB slave with memory interface
4. UART transmitter
5. UART receiver
6. APB master
7. FIFO flush logic
8. Debouncing circuit
9. SPI master
10. SPI slave
11. I2C master controller
12. AHB master
13. AHB Slave
14. log2 function


================================================================== TBD ==================================================================


1. Clock Divider: Create a clock divider that generates a slower clock signal from a given input clock., divide by 3 clk
2. Digital PLL: Design a Phase-Locked Loop (PLL) that locks the output frequency to the input reference frequency with adjustable phase and frequency.
3. Cache Memory: Design a 4-way set-associative cache with a 16-entry cache size and implement cache read and write policies.
4. Floating-Point Unit: Create a basic floating-point arithmetic unit that supports addition and subtraction operations.
5. DMA Controller: Design a Direct Memory Access (DMA) controller that can transfer data between memory and peripherals without CPU intervention.
6. Cyclic Redundancy Check (CRC): Create a module that computes a CRC for error detection in data transmission.
7. Floating-Point Multiplication: Implement a floating-point multiplier that supports IEEE 754 single-precision floating-point format.
8. Configurable Logic Block (CLB): Create a configurable logic block with a flexible interconnect network that can be used to implement various combinational and sequential logic.
9. Error Detection and Correction (ECC): Create an ECC module that detects and corrects single-bit errors in memory.
10. AXI master interface
11. AXI slave interface
12. Divider:Create a synchronous divider that divides two N-bit numbers and outputs the quotient and remainder.
13. Square Root Calculator: Design a circuit that computes the integer square root of an N-bit input.
14. Matrix Multiplier: Implement a circuit that multiplies two square matrices of size N x N.
15. Digital Signal Processing (DSP) Filters: Implement a finite impulse response (FIR) filter that processes an input signal and outputs the filtered signal.
16. Polynomial Evaluator: Design a circuit that evaluates a polynomial of degree N for a given input value.
17. Sigmoid function
18. Tanh function
19. Softmax function


many more to come....



