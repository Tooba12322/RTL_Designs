// I2C master module implementation 
// Here data is transferred based on cmd input
// sclk signal is generated by master and is different from system clk
// source : https://www.youtube.com/watch?v=WeHVkYPdDr4&list=PL-iIOnHwN7NUpkOWAQ9Fc7MMddai9vHvN&index=109

`timescale 1ns/1ps

module i2c_m (rd_out,ready,sclk,cmd_done,ack,sda,store,din,dvsr,start,cmd,clk,rst);
  
  output logic ready,cmd_done,ack;
  output logic [7:0] rd_out;
  inout tri sda;
  output tri sclk;
  input logic store,start,clk,rst;
  input logic [2:0] cmd;
  input logic [7:0] din;
  input logic [15:0] dvsr;
  
  parameter START   = 3'd0;
  parameter WRITE   = 3'd1;
  parameter READ    = 3'd2;
  parameter STOP    = 3'd3;
  parameter RESTART = 3'd4;
  
  logic [8:0] tx_reg,tx_nxt;
  logic [8:0] rx_reg,rx_nxt;
  logic [15:0] cnt, cnt_nxt;
  logic [2:0] cmd, cmd_nxt;
  logic [15:0] qrtr, half;
  logic sda_reg, sda_nxt, sclk_reg, sclk_nxt;
  

  typedef enum logic [3:0] {idle, start1, start2, hold, data1, data2, data3, data4, 
                            data_end, stop1, stop2, restart} state;
  state pr_state,nx_state;

  always @(posedge clk or negedge rst) begin
    if (!rst) begin
      cnt       <= '0;
      tx_reg    <= '0;
      cmd       <= '0;
      rx_reg    <= '0;
      sda_reg   <= '1;
      sclk_reg  <= '1;
    end
    else begin
      cnt       <= cnt_nxt;
      tx_reg    <= tx_nxt;
      cmd       <= cmd_nxt;
      rx_reg    <= rx_nxt;
      sda_reg   <= sda_nxt;
      sclk_reg  <= sclk_nxt;
    end
  end
  
  always @(posedge clk or negedge rst) begin
    if (!rst) pr_state <= idle;
    else pr_state <= nx_state;
  end   
  
  always @(*) begin
      nx_state      = pr_state; //default values
      cnt_nxt       = cnt;
      cmd_nxt       = cmd;
      tx_nxt        = tx_reg;
      rx_nxt        = rx_reg;
      sda_nxt       = sda_reg;
      sclk_nxt      = sclk_reg;
      cmd_done      = '0;
      ready         = '0; // during data transfer ready=0
          
    case (pr_state) 
      idle      : begin
                     ready = '1;
                     if (start == '1) begin
                       if (cpha) nx_state   =  cpha_delay;
                       else nx_state   =  drive;
                       dout_nxt   = din;
                     end
                   end
      
      cpha_delay : begin // wait for next cycle, as if cpha = '1, driving should be at clk edge 
                     if (cnt == dvsr) begin
                       nx_state   =  drive;
                       cnt_nxt    = '0;
                     end
                     else cnt_nxt = cnt + 16'd1;
                   end
      
      drive      : begin // in next sclk cycle, capture miso input into data_in reg
                     if (cnt==dvsr) begin
                       din_nxt  = {data_in[6:0],miso};
                       nx_state = sample;
                       cnt_nxt = '0;
                     end
                     else cnt_nxt = cnt + 16'd1;
                   end
        
      sample     : begin // in next sclk cycle, deliver mosi output from dout reg, repeat till all DBITS are sent/captured
                     if (cnt ==  dvsr) begin
                       if (dbits_cnt == DBITS - 1) begin
                         nx_state = idle;
                         cnt_nxt  = '0;
                         done_nxt = '1;
                         dbits_cnt_nxt = '0;
                         din_nxt  = {data_in[6:0],miso};// for last bit to be captured
                       end
                       else begin
                         dbits_cnt_nxt = dbits_cnt + 3'd1;
                         dout_nxt = {dout_reg[6:0],1'b0};
                         nx_state = drive;
                         cnt_nxt  = '0;
                       end 
                     end
                     else cnt_nxt = cnt + 16'd1;
                   end
     endcase
  end
  
  //sclk generation
  assign iclk = (nx_state==sample && !cpha) || (nx_state==drive && cpha);
  assign sclk_nxt = (cpol) ? !iclk : iclk;
  
  assign dout = (done) ? data_in : '0; // drive input reg contents at the end, should equal to 8 miso bits received serially
  assign mosi = dout_reg[7]; // drive mosi output pin
  assign sclk = sclk_reg; // drive sclk output
  
endmodule
