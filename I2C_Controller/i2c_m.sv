// I2C master module implementation 
// Here data is transferred based on cmd input
// sclk signal is generated by master and is different from system clk
// source : https://www.youtube.com/watch?v=WeHVkYPdDr4&list=PL-iIOnHwN7NUpkOWAQ9Fc7MMddai9vHvN&index=109

`timescale 1ns/1ps

module i2c_m (rd_out,ready,sclk,cmd_done,ack,sda,store_cmd,din,dvsr,start,cmd,clk,rst);
  
  output logic ready,cmd_done,ack;
  output logic [7:0] rd_out;
  inout tri sda;
  output tri sclk;
  input logic store_cmd,start,clk,rst;
  input logic [2:0] cmd;
  input logic [7:0] din;
  input logic [15:0] dvsr;
  
  parameter START   = 3'd0;
  parameter WRITE   = 3'd1;
  parameter READ    = 3'd2;
  parameter STOP    = 3'd3;
  parameter RESTART = 3'd4;
  
  logic [8:0] tx_reg,tx_nxt;
  logic [8:0] rx_reg,rx_nxt;
  logic [15:0] cnt, cnt_nxt;
  logic [2:0] cmd_reg, cmd_nxt;
  logic [15:0] qrtr, half;
  logic sda_reg, sda_nxt;
  logic sclk_reg, sclk_nxt;
  logic [3:0] bit_cnt, bit_cnt_nxt;
  logic nack, data_phase;
  

  typedef enum logic [3:0] {idle, start1, start2, hold, data1, data2, data3, data4, 
                            data_end, stop1, stop2, restart} state;
  state pr_state,nx_state;

  always @(posedge clk or negedge rst) begin
    if (!rst) begin
      cnt       <= '0;
      tx_reg    <= '0;
      cmd_reg   <= '0;
      rx_reg    <= '0;
      bit_cnt   <= '0;
      sda_reg   <= '1;
      sclk_reg  <= '1;
    end
    else begin
      cnt       <= cnt_nxt;
      tx_reg    <= tx_nxt;
      cmd_reg   <= cmd_nxt;
      bit_cnt   <= bit_cnt_nxt;
      rx_reg    <= rx_nxt;
      sda_reg   <= sda_nxt;
      sclk_reg  <= sclk_nxt;
    end
  end
  
  always @(posedge clk or negedge rst) begin
    if (!rst) pr_state <= idle;
    else pr_state <= nx_state;
  end   
  
  always @(*) begin
      nx_state      = pr_state; //default values
      cnt_nxt       = cnt+1;
      cmd_nxt       = cmd_reg;
      tx_nxt        = tx_reg;
      rx_nxt        = rx_reg;
      bit_cnt_nxt   = bit_cnt;
      sda_nxt       = '1;
      sclk_nxt      = '1;
      data_phase    = '0;
      cmd_done      = '0;
      ready         = '0; // during data transfer ready=0
          
    case (pr_state) 
      idle      : begin
                    ready = '1;
                    if (store_cmd == '1 && cmd==START) begin
                      nx_state   =  start1;
                      cnt_nxt    =  '0;
                      cmd_nxt    =  cmd;
                    end
                  end
      
      start1    : begin 
                    sda_nxt = '0;
                    if (cnt == half) begin
                       nx_state   =  start2;
                       cnt_nxt    = '0;
                    end
                  end
      
      start2    : begin 
                    sda_nxt  = '0;
                    sclk_nxt = '0;
                    if (cnt==half) begin
                      cmd_done  = '1;
                      nx_state  = hold;
                      cnt_nxt = '0;
                    end
                  end
        
      hold      : begin
                    ready = '1;
                    sda_nxt  = '0;
                    sclk_nxt = '0;
                    if (store_cmd == '1) begin
                      cmd_nxt  = cmd;
                      cnt_nxt  = '0;
                      case (cmd)
                        STOP           : nx_state  = stop1;
                        RESTART, START : nx_state  = start1;
                        default        : begin
                                           nx_state    = data1;
                                           bit_cnt_nxt = '0;
                                           tx_nxt      = {din,nack};
                                         end
                      endcase
                    end
                  end
      
       data1    : begin
                    sda_nxt    = tx_reg[8];
                    sclk_nxt   = '0;
                    data_phase = '1;
                    if (cnt == qrtr) begin
                       nx_state   =  data2;
                       cnt_nxt    = '0;
                    end
                  end
      
       data2    : begin
                    sda_nxt    = tx_reg[8];
                    data_phase = '1;
                    if (cnt == qrtr) begin
                       nx_state   =  data3;
                       cnt_nxt    = '0;
                       rx_nxt     = {rx_reg[7:0],sda};
                    end
                  end
      
       data3    : begin
                    sda_nxt    = tx_reg[8];
                    data_phase = '1;
                    if (cnt == qrtr) begin
                       nx_state   =  data4;
                       cnt_nxt    = '0;
                    end
                  end
      
       data4    : begin
                    sda_nxt    = tx_reg[8];
                    sclk_nxt   = '0;
                    data_phase = '1;
                    if (cnt == qrtr) begin
                       nx_state   =  data_end;
                       cnt_nxt    = '0;
                    end
                  end
      
       data_end : begin
                    sda_nxt    = '0;
                    sclk_nxt   = '0;
                    if (cnt == qrtr) begin
                       nx_state   =  hold;
                       cnt_nxt    = '0;
                       cmd_done   = '1;
                    end
                  end
      
       stop1    : begin 
                    sda_nxt = '0;
                    if (cnt == half) begin
                       nx_state   =  stop2;
                       cnt_nxt    = '0;
                    end
                  end
      
       stop2    : begin 
                    sda_nxt  = '1;
                    if (cnt==half) begin
                      cmd_done  = '1;
                      nx_state  = idle;
                      cnt_nxt = '0;
                    end
                  end
             
       restart  : begin 
                   if (cnt==half) begin
                      cmd_done  = '1;
                      nx_state  = start1;
                      cnt_nxt = '0;
                    end
                  end
     endcase
  end
  
  //sclk generation
  
  assign sclk = (sclk_reg) ? 1'bz : 1'b0;
  
  assign qrtr = dvsr;
  assign half = qrtr<<1;
  assign rd_dout = rx_reg[8:1]; // drive read reg contents at the end, should equal to 8-bits received serially
  assign ack     = rx_reg[0];
  assign nack    = tx_reg[0];
  
endmodule
