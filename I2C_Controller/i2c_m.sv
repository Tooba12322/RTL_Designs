// I2C master module implementation 
// Here data is transferred based on cmd input
// sclk signal is generated by master and is different from system clk
// source : https://www.youtube.com/watch?v=WeHVkYPdDr4&list=PL-iIOnHwN7NUpkOWAQ9Fc7MMddai9vHvN&index=109

`timescale 1ns/1ps

module i2c_m (rd_out,ready,sclk,cmd_done,ack,sda,store_cmd,din,dvsr,cmd,clk,rst);
  
  output logic ready,cmd_done,ack;
  output logic [7:0] rd_out;
  inout tri sda;
  output tri sclk;
  input logic store_cmd,clk,rst;
  input logic [2:0] cmd;
  input logic [7:0] din;
  input logic [15:0] dvsr; // divisor for sclk generation counter

  // Commands 
  parameter START   = 3'd0;
  parameter WRITE   = 3'd1;
  parameter READ    = 3'd2;
  parameter STOP    = 3'd3;
  parameter RESTART = 3'd4;
  
  logic [8:0] tx_reg,tx_nxt; // output reg
  logic [8:0] rx_reg,rx_nxt; // input reg
  logic [15:0] cnt, cnt_nxt; // tick counter
  logic [2:0] cmd_reg, cmd_nxt; // command reg
  logic [15:0] qrtr, half; // tick generation thresholds
  logic sda_reg, sda_nxt; // sda output reg
  logic sclk_reg, sclk_nxt; // sclk output reg
  logic [3:0] bit_cnt, bit_cnt_nxt; // counter for counting total bit sent/recived
  logic nack, data_phase, receive; // not ack, data transfer, data reception
  

  typedef enum logic [3:0] {idle, start1, start2, hold, data1, data2, data3, data4, 
                            data_end, stop1, stop2, restart} state;
  state pr_state,nx_state;

  always @(posedge clk or negedge rst) begin
    if (!rst) begin
      cnt       <= '0;
      tx_reg    <= '0;
      cmd_reg   <= '0;
      rx_reg    <= '0;
      bit_cnt   <= '0;
      sda_reg   <= '1;
      sclk_reg  <= '1;
    end
    else begin
      cnt       <= cnt_nxt;
      tx_reg    <= tx_nxt;
      cmd_reg   <= cmd_nxt;
      bit_cnt   <= bit_cnt_nxt;
      rx_reg    <= rx_nxt;
      sda_reg   <= sda_nxt;
      sclk_reg  <= sclk_nxt;
    end
  end
  
  always @(posedge clk or negedge rst) begin
    if (!rst) pr_state <= idle;
    else pr_state <= nx_state;
  end   
  
  always @(*) begin
      nx_state      = pr_state; //default values
      cnt_nxt       = cnt+1;
      cmd_nxt       = cmd_reg;
      tx_nxt        = tx_reg;
      rx_nxt        = rx_reg;
      bit_cnt_nxt   = bit_cnt;
      sda_nxt       = '1; // by default sda and sclk are pulled high
      sclk_nxt      = '1;
      data_phase    = '0;
      cmd_done      = '0;
      ready         = '0; // during data transfer ready=0
          
    case (pr_state) 
      idle      : begin // assert ready to slave, check for start command
                    ready = '1;
                    if (store_cmd == '1 && cmd==START) begin
                      nx_state   =  start1;
                      cnt_nxt    =  '0;
                      cmd_nxt    =  cmd;
                    end
                  end
      
      start1    : begin // drive sda=0, wait for cnt = 2*dvsr, why? please check source video
                    sda_nxt = '0;
                    if (cnt == half) begin
                       nx_state   =  start2;
                       cnt_nxt    = '0;
                    end
                  end
      
      start2    : begin // drive sda=0,sclk=0 wait for cnt = 2*dvsr, why? please check source video, assert start cmd done
                    sda_nxt  = '0;
                    sclk_nxt = '0;
                    if (cnt==half) begin
                      cmd_done  = '1;
                      nx_state  = hold;
                      cnt_nxt = '0;
                    end
                  end
        
      hold      : begin // drive sda=0, sclk=0,check for next command, if WR/RD store din in tx_reg 
                    ready = '1;
                    sda_nxt  = '0;
                    sclk_nxt = '0;
                    if (store_cmd == '1) begin
                      cmd_nxt  = cmd;
                      cnt_nxt  = '0;
                      case (cmd)
                        STOP           : nx_state  = stop1;
                        RESTART, START : nx_state  = start1;
                        default        : begin
                                           nx_state    = data1;
                                           bit_cnt_nxt = '0;
                                           tx_nxt      = {din,nack};
                                         end
                      endcase
                    end
                  end
      
       data1    : begin // drive first data MSB bit of din stored in tx_reg, wait for cnt= dvsr
                    sda_nxt    = tx_reg[8];
                    sclk_nxt   = '0;
                    data_phase = '1;
                    if (cnt == qrtr) begin
                       nx_state   =  data2;
                       cnt_nxt    = '0;
                    end
                  end
      
       data2    : begin  // drive first data MSB bit of din stored in tx_reg, wait for cnt= dvsr
                    sda_nxt    = tx_reg[8];
                    data_phase = '1;
                    if (cnt == qrtr) begin
                       nx_state   =  data3;
                       cnt_nxt    = '0;
                       rx_nxt     = {rx_reg[7:0],sda};
                    end
                  end
      
       data3    : begin  // drive first data MSB bit of din stored in tx_reg, wait for cnt= dvsr
                    sda_nxt    = tx_reg[8];
                    data_phase = '1;
                    if (cnt == qrtr) begin
                       nx_state   =  data4;
                       cnt_nxt    = '0;
                    end
                  end
      
      data4    : begin  // drive first data MSB bit of din stored in tx_reg, wait for cnt= dvsr, check for bit count
                    sda_nxt    = tx_reg[8];
                    sclk_nxt   = '0;
                    data_phase = '1;
                    if (cnt == qrtr) begin
                      cnt_nxt    = '0;
                      if (bit_cnt==4'd8) begin
                        nx_state    =  data_end;
                        bit_cnt_nxt ='0;
                      end
                      else begin
                        nx_state    =  data1;
                        bit_cnt_nxt = bit_cnt + 4'd1;
                        tx_nxt     = {tx_reg[7:0],nack};
                      end
                    end
                  end
      
       data_end : begin
                    sda_nxt    = '0;
                    sclk_nxt   = '0;
                    if (cnt == qrtr) begin
                       nx_state   =  hold;
                       cnt_nxt    = '0;
                       cmd_done   = '1;
                    end
                  end
      
       stop1    : begin // drive sda=0, wait for cnt = 2*dvsr, why? please check source video
                    sda_nxt = '0;
                    if (cnt == half) begin
                       nx_state   =  stop2;
                       cnt_nxt    = '0;
                    end
                  end
      
       stop2    : begin // drive sda=1, wait for cnt = 2*dvsr, why? please check source video, assert stop cmd done
                    sda_nxt  = '1;
                    if (cnt==half) begin
                      cmd_done  = '1;
                      nx_state  = idle;
                      cnt_nxt = '0;
                    end
                  end
             
       restart  : begin //  wait for cnt = 2*dvsr, why? please check source video, assert restart cmd done
                   if (cnt==half) begin
                      cmd_done  = '1;
                      nx_state  = start1;
                      cnt_nxt = '0;
                    end
                  end
     endcase
  end
  
  //sclk generation
  assign sclk = (sclk_reg) ? 1'b1 : 1'b0;
  
  //sda generation
  assign receive = (data_phase && bit_cnt<8 && cmd_reg==READ) || (data_phase && bit_cnt==8 && cmd_reg==WRITE);
  assign sda     = (receive || sda_reg) ? 1'b1 : 1'b0;
  
  assign qrtr = dvsr; // input divisor value, based on sclk and system clk requirements, check formula from source video
  assign half = qrtr<<1; // 2*qrtr
  assign rd_out = rx_reg[8:1]; // drive read reg contents at the end, should equal to 8-bits received serially
  assign ack     = rx_reg[0]; // ack is the acknowledge received upon write
  assign nack    = tx_reg[0]; // nack is the acknowledge to be sent upon read completion
  
endmodule
